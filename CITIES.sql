SELECT * FROM cities.cities;


# FOR EACH COUNTRY FIND THE MOST POPULATED CITY.

SELECT country,
		city,
        MAX(POPULATION)
FROM cities
GROUP BY country;

--------------------------------------------------------------------------------------------

# SELECT THE 2 MOST POPULATED CITIES FOR EACH COUNTRY

WITH CITY_TANKE_TABLE AS 
						(SELECT country,
								CITY,
								POPULATION,
								RANK() OVER(PARTITION BY COUNTRY ORDER BY POPULATION DESC) AS CITY_RANK # ROW_NUMBER() CAN BE USED HERE INSTEAD OF RANK()
						FROM cities)
SELECT ROW_NUMBER() OVER() ID, # THIS LINE JUST COUNTS THE NUMBER OF ROWS
	    country,
		city,
		population
FROM CITY_TANKE_TABLE
WHERE CITY_RANK <= 2; # WHERE CALUSE ON COLUMN CREATED BY WINDOW FUNCTION CAN'T BE ON THE SAM QUERY SO WE NEED TO PUT  WINDOW FUNCTION IN A  TEMP TABLE

------------------------------------------------------------------------------------------------------

## FIRST FIND OLD AND YOUNG CITIES, age BELOW 110 IS YOUNG AND ABOVE 100 IS OLD.
# THEN FOR EACH AGE CATEGORY OF CITIES, FIND THE HIGHEST POPULATED CITIES OF EACH COUNTRY.

WITH CITIES_YOUNG_OLD AS (
						SELECT * ,
							   CASE
									WHEN AGE >= 110 THEN 'OLD'
									ELSE 'YOUNG'
								END AS YOUNG_OLD # NEW COLUMN 'YOUNG_OLD' IS CREATED
						FROM CITIES_AGE),
                        
CITIES_AGE_RANK AS (
						SELECT *, 
                        RANK() OVER(PARTITION BY YOUNG_OLD, COUNTRY ORDER BY POPULATION DESC, country) AS CITY_AGE_RANK
						FROM CITIES_YOUNG_OLD ) # WINDOW FUNCTION AND THE COLUMN CREATED IN CASE CLUAE CAN'T BE ON THE SAME QUERY SO WE NEED TO USE N2 TEMP TABLES 

SELECT country,
		city,
        YOUNG_OLD,
        population
FROM CITIES_AGE_RANK
WHERE CITY_AGE_RANK = 1;

